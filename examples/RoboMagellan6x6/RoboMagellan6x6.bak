#include <Wire.h>
#include <MINDSi.h>
#include <Servo.h>
#include <greatcircle.h>
#include <NMEA.h>
#include <EEStream.h>
point entryway(47.4048233032,-117.0587387084);
point eastDoor(47.674638, -117.098031);
point westDoor(47.674579, -117.098202);
point centerParking(47.674556, -117.098094);
point halfEastParking(47.674697, -117.097712);
point eastEndParking(47.674864, -117.097282);
point halfWestParking(47.674432, -117.098442);
point westEndParking(47.674288, -117.098859);
point westDrain(47.674426, -117.098483);
point halfWestSidewalk(47.674468, -117.098483);
point westEndSidewalk(47.674343, -117.098849);
point eastDrain(47.674674, -117.097933);
point halfEastGrass(47.674751, -117.097724);
point lotCenter(47.674226, -117.100168);
point lotSouthEast(47.674127, -117.099483);
point lotNorthEast(47.674880, -117.100011);
point lotNorthWest(47.674661, -117.101264);
point lotSouthWest(47.673755, -117.100463);
point lotMound(47.674577, -117.100808);
point HouseCorner(47.7261352539, -116.9615859985);
const int LEDR = 27;
const int LEDY = 26;
const int LEDB = 25;
const int drivePin = 7;
const int steerPin = 8;
NMEA nmea(Serial1);
Servo drive,steer;
point* target;
point location(0,0);
double heading;
double compass;
double distance;
int direction;
int dirTune=0;

void setup() {
	beginCompass();
	target = &entryway;
	drive.attach(drivePin);
	steer.attach(steerPin);
	Serial1.begin(9600);
	Serial.begin(115200);
	pinMode(LEDR, OUTPUT);
	pinMode(LEDB, OUTPUT);
	delay(1000);
}

void loop() {
	nmea.update();
	if(nmea.newData()){
		location = nmea.getLocation();
		location.update(location.degLatitude()/100,location.degLongitude()/100);
		heading = calcHeading(*target, location);
		distance = calcDistance(location, *target);
		if(!nmea.getWarning()){
			writeMessage();
		}
		digitalWrite(LEDB, nmea.getWarning()); //blue will turn on if a signal is indicated
		digitalWrite(LEDR, !(distance < 1.) ); //red will turn on if target is within a mile
	}

	compass = .9*compass + .1*(-(getHeading()-nmea.getMagVar()));		//clean up negatives
	direction = (heading - compass) - 90; //90 degree offset total guess
	if(abs(direction)>180) direction = (360-abs(direction)) * (-direction/abs(direction));

	direction+=90+dirTune;
	if(direction < 50) direction = 50;
	else if(direction > 130) direction = 130;
	steer.write( direction );
	drive.write(110);

	if( analogRead(A0) < 40 ) *target = location;
	else if( analogRead(A0) < 200 ) dirTune++;
	else if( analogRead(A0) < 800 ) dirTune--;
}

void writeMessage(){
/*	EEStream.print(location.degLatitude(),DEC); EEStream.print(",");
	EEStream.print(location.degLongitude(),DEC); EEStream.print("\t");*/
	EEStream.print(heading); EEStream.print(":");
	EEStream.print(nmea.getCourse()); EEStream.print(":");
	EEStream.print(compass); EEStream.print("\t");
	EEStream.println(direction);
}

//Analog pin {(12?), 13} associated with voltage on APM 2.5; V = 0.128571+0.0504464*analogRead(A13);
/*double ratio = nmea.groundSpeed/5
if(ratio > 1) ratio = 1;
else if(ratio < 0) ratio = 0;
int direction = heading - ((getHeading()*(1-ratio)) + (nmea.course*(ratio)) -nmea.magVar);*/
